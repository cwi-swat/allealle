world (wId: id, event:int) >= {<w1,0>} <= {<w1,0>,<w2,?>..<w3,?>}
ordering (wId:id, next:id) <= {<w1,w2>,<w2,w3>}
first (wId:id) = {<w1>}

/////////////////////

Machine (mId: id)  = {<m1>}

State (sId:id)    = {<opened>,<closed>}
statesInWorld (wId:id, mId:id, sId:id)  >= {<w1,m1,opened>} <= {<w1,m1,opened>..<w3,m1,opened>,<w2,m1,closed>..<w3,m1,closed>}

initialState (wId:id,mId:id,sId:id) <= {<w2,m1,opened>..<w3,m1,opened>,<w2,m1,closed>..<w3,m1,closed>}

///////////////////

ordering ⊆ world[wId] ⨯ world[wId][wId as next]

statesInWorld ⊆ world[wId] ⨯ Machine ⨯ State
initialState ⊆ world[wId] ⨯ Machine ⨯ State

∀ w ∈ world[wId] | w ⊆ (first ⨝ *<wId,next>ordering)[next][next as wId]

// Conditions that need to be reached in order to call the model consistent
// There must be a initial state per statemachine
∃ w ∈ world | ∀ m ∈ Machine | 
  // Add all the rules of the meta-model here
  one (initialState ⨝ w ⨝ m) ∧ 
  some (statesInWorld ⨝ w ⨝ m)[count() as nr] where nr = 2
  
∀ o ∈ ordering | let cur= o[wId], next = o[next][next as wId] |
  (∃ m ∈ Machine | let statesInCur = (statesInWorld ⨝ cur ⨝ m)[sId], statesInNext= (statesInWorld ⨝ next ⨝ m)[sId],
                       initStateInCur = (initialState ⨝ cur ⨝ m)[sId], initStateInNext = (initialState ⨝ next ⨝ m)[sId] |  
    (
      // add an initial state
      (one (initStateInNext ∖ initStateInCur) ∧ statesInCur = statesInNext ∧ some (next ⨝ world) where event = 1) ∨ 
      // delete an initial state
      (one (initStateInCur ∖ initStateInNext) ∧ statesInCur = statesInNext ∧ some (next ⨝ world) where event = 2) ∨ 
      // add a state
      (one (statesInNext ∖ statesInCur) ∧ initStateInCur = initStateInNext ∧ some (next ⨝ world) where event = 3) ∨ 
      // delete a state
      (one (statesInCur ∖ statesInNext) ∧ initStateInCur = initStateInNext ∧ some (next ⨝ world) where event = 4)
    ) ∧ 
    // frame the other machines, only one machine can change
    (∀ otherM ∈ Machine ∖ m | (statesInWorld ⨝ cur ⨝ otherM)[sId] = (statesInWorld ⨝ next ⨝ otherM)[sId] ∧ (initialState ⨝ cur ⨝ otherM)[sId] = (initialState ⨝ next ⨝ otherM)[sId]) 
  )

objectives: minimize world[count() as nr]

