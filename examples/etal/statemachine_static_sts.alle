IntState (1 :: event:int) >= {<is1,0>} <= {<is1,0>,<is2,?>..<is3,?>}
ordering (2) <= {<is1,is2>,<is2,is3>}
first    (1) = {<is1>}

Machine (1)  = {<m1>}

State (1)    = {<opened>,<closed>}
state (3)    >= {<is1,m1,opened>,<is1,m1,closed>} <= {<is1,m1,opened>..<is3,m3,opened>,<is1,m1,closed>..<is3,m3,closed>}

initialState (3) <= {<is2,m1,opened>..<is3,m1,opened>,<is2,m1,closed>..<is3,m1,closed>} // >= {<is1,m1,opened>,<is1,m1,closed>}

//transition (4) >= {<is1,m1,opened,closed>} <= {<is1,m1,opened,closed>..<is3,m1,opened,closed>,<is2,m1,closed>,<is3,m1,closed>}

ordering in IntState->IntState

state in IntState->Machine->State
initialState in IntState->Machine->State

forall s:IntState | s in first.*ordering

// Conditions that need to be reached in order to call the model consistent
// There must be a initial state
exists s:IntState | forall m:Machine | one m.(s.initialState)
// There must be a state where machines have two states
//exists s:IntState | forall m:Machine | #m.(s.state) = 2

// Transition function
forall s1:IntState, s2:IntState\s1 | s1->s2 in ordering =>
  (exists m:Machine | 
    (
      // add an initial state
      (one (m.(s2.initialState)) \ (m.(s1.initialState)) && m.(s2.state) = m.(s1.state) && s2::event = 1) ||
      // delete an initial state
      (one (m.(s1.initialState)) \ (m.(s2.initialState)) && m.(s2.state) = m.(s1.state) && s2::event = 2) ||
      // add a state
      (one (m.(s2.state)) \ (m.(s1.state)) && m.(s2.initialState) = m.(s1.initialState) && s2::event = 3) ||
      // delete a state
      (one (m.(s1.state)) \ (m.(s2.state)) && m.(s2.initialState) = m.(s1.initialState) && s2::event = 4)
    )
    &&
    // All other machines should not change
    (forall m2:Machine\m | m2.(s1.state) = m2.(s2.state) && m2.(s1.initialState) = m2.(s2.initialState)) 
  )

minimize #IntState

