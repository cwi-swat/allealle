State (1 :: amount:int)     >= {<s1,0>} <= {<s1,0>,<s2,?>..<s5,?>}
InitialState (1)             = {<s1>}
ordering (2)                <= {<s1,s2>,<s2,s3>,<s3,s4>,<s4,s5>}
Account (1 :: balance:int)  >= {<ac1,?>} <= {<ac1,?>..<ac5,?>}
accountInState (2)          >= {<s1,ac1>} <= {<s1,ac1>,<s2,ac2>,<s3,ac3>,<s4,ac4>,<s5,ac5>}

Withdraw (1)                = {<withdraw>}
Deposit (1)                 = {<deposit>}
triggeredEvent (2)          <= {<s2,withdraw>..<s5,withdraw>,<s2,deposit>..<s5,deposit>}

ordering in State -> State
accountInState in State->Account 
triggeredEvent in State->(Withdraw+Deposit)

// Entity constraints
forall s:State | some s.accountInState
State in InitialState.*ordering
Account in (InitialState.*ordering).accountInState

(State\InitialState)::amount > 0 && State::amount < 11

// Initial state
(InitialState.accountInState)::balance = 0

// Transition function
forall s1: State, s2:State | s1 -> s2 in ordering => 
  (
    ((s2.accountInState)::balance = (s1.accountInState)::balance + s2::amount && s2.triggeredEvent = Deposit) ||
    ((s1.accountInState::balance >= s2::amount &&  (s2.accountInState)::balance = (s1.accountInState)::balance - s2::amount) && s2.triggeredEvent = Withdraw)
  )
 
// Goal state 
exists s:State | (s.accountInState)::balance = 40

minimize #State
