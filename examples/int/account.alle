State (1 :: amount:int)     >= {<s1,0>} <= {<s1,0>,<s2,?>,<s3,?>,<s4,?>}
InitialState (1)            = {<s1>}
ordering (2)                <= {<s1,s2>,<s2,s3>,<s3,s4>}
Account (1 :: balance:int)  >= {<ac1,?>} <= {<ac1,?>,<ac2,?>,<ac3,?>,<ac4,?>}
accountInState (2)          >= {<s1,ac1>} <= {<s1,ac1>,<s2,ac2>,<s3,ac3>,<s4,ac4>}

Withdraw (1)                = {<withdraw>}
Deposit (1)                 = {<deposit>}
triggeredEvent (2)          <= {<s2,withdraw>,<s2,deposit>,<s3,withdraw>,<s3,deposit>,<s4,withdraw>,<s4,deposit>}

ordering in State -> State
accountInState in State -> Account 

triggeredEvent in State->(Withdraw+Deposit)

// Entity constraints
forall s:State | some s.accountInState
forall s:State\InitialState | s in InitialState.^ordering

(State\InitialState)::amount > 0 && State::amount < 11

// Initial state
(InitialState.accountInState)::balance = 0

// Transition function
forall s1: State, s2:State | s1 -> s2 in ordering => 
  (
    ((s2.accountInState)::balance = (s1.accountInState)::balance + s2::amount && s2.triggeredEvent = Deposit) ||
    ((s1.accountInState::balance >= s2::amount &&  (s2.accountInState)::balance = (s1.accountInState)::balance - s2::amount) && s2.triggeredEvent = Withdraw)
  )
 
// Goal state 
exists s:State | (s.accountInState)::balance = 30
