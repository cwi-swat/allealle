File (id:id, depth:int, size:int) >= {<f1,3,100>} <= {<f1,3,100>,<f2,?,?>,<f3,?,?>}
Dir (id:id, depth:int, size:int)  <= {<d0,?,?>..<d2,?,?>}
Root (id:id)                       = {<d0>}
contents (from:id, to:id)         >= {<d0,d1>} <= {<d0,d0>..<d2,d2>,<d0,f1>..<d2,f3>}

// BASIC RELATIONAL CONSTRAINTS
// Only dirs can contain other dirs and files
contents ⊆ Dir[id][from/id] ⨯ (Dir[id] ∪ File[id])[to/id]
// A dir cannot contain itself
∀ d ∈ Dir[id] | ¬ (d[to/id] ⊆ (d[from/id] ⨝ ^<from,to>contents)[to])
// Root is a Dir 
Root ⊆ Dir[id]
// All files and dirs are (reflexive-transitive) 'content' of the Root dir 
(File[id] ∪ Dir[id])[to/id] ⊆ (Root[from/id] ⨝ *<from,to>contents)[to]
// All files and dirs can only be contained by one dir
∀ f ∈ (File ∪ Dir)[id] | lone contents ⨝ f[to/id]

// INTEGER CONSTRAINTS
// All files have a positive size
∀ f ∈ File | some f where size > 0
// The size of a dir is the sum of all the files that are directly or transitively part of this directory
∀ d ∈ Dir | some (d ⨯ ((d[id][from/id] ⨝ ^<from,to>contents)[to][id/to] ⨝ File)[totalSizeOfReachableFiles/sum(size)]) where size = totalSizeOfReachableFiles   

∀ d ∈ Dir[id,depth], o ∈ (Dir ∪ File)[id,depth] | o[id][to/id] ⊆ (d[id][from/id] ⨝ contents)[to] ⇒ 
                                                  some ((o[d1/depth,to/id] ⨯ d[d2/depth]) where (d1 = d2 + 1))  
// The depth of Root is 0
some (Root ⨝ Dir) where depth = 0 
