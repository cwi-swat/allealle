Elem (eId:id, val:int) <= {<n1,?>..<n3,?>}
Start (eId:id)         <= {<n1>..<n3>}
ring (from:id,to:id)   <= {<n1,n1>..<n3,n3>}

ring ⊆ Elem[eId][from/eId] ⨯ Elem[eId][to/eId]
Start ⊆ Elem[eId] 

∀ e ∈ Elem | some e where val > 0

// One of the elements in the ring is considered the start element
one Start

// The ring is cyclic, all elements should be reachable from the start element (including itself) 
Elem[eId] ⊆ (Start[from/eId] ⨝ *<from,to>ring)[to][eId/to]

// Only one element leads to an other element
∀ e ∈ Elem | one e[from/eId] ⨝ ring ∧ one e[to/eId] ⨝ ring

// All elements in the ring have incrementing values starting from the Start ring
∀ r ∈ ring | let e = r[from][eId/from] ⨝ Elem, e' = r[to][eId/to] ⨝ Elem | 
  ¬ (e'[eId] ⊆ Start) ⇒ some (e ⨯ e'[eId'/eId,val'/val]) where val' = (val + 1)
  
