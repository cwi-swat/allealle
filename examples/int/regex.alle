// Encoding of regex ^[a-d]+[d-f]*[l-n]$

// Below definition of relations generates strings up to a length of 10 that conform to the regex
Step (1 :: label:int, char:int) <= {<s1,0,0>,<s2,?,?>..<s6,?,?>}
trans (2)                       <= {<s1,s2>,<s2,s3>,<s3,s4>,<s4,s5>,<s5,s6>}
Initial (1)                      = {<s1>}
Final (1)                       <= {<s1>..<s6>}

// Below definition of relations checks whether the string 'baan' matches the regex 
//Step (1 :: label:int, char:int)    = {<s1,0,0>,<s2,?,98>,<s3,?,97>,<s4,?,97>,<s5,?,110>} // 98 = b, 97 = a, 97 = a, 110 = n
//trans (2)                          = {<s1,s2>,<s2,s3>,<s3,s4>,<s4,s5>}
//Initial (1)                        = {<s1>}
//Final (1)                          = {<s5>}

// Generic constraints, equal for all regexes
trans in Step->Step
Initial in Step
Step in Initial.*trans

(Step\Initial)::char > 0

Final in Step
// There can only be 1 final step
one Final
// There are no transitions possible after the final step
no Final.trans

// Specific encoding for this regex as NFA
Step::label >= 0 && Step::label <= 3

Initial::label = 0
Final::label = 3

forall t:trans | let s:t.Step, s':Step.t | 
  (s::label = 0 =>
    (s'::char >= 97 && s'::char <= 100 && s'::label = 1) // accept character in class [a-d]+, move to state [a-d]+
  ) &&  
  (s::label = 1 => 
    ((s'::char >= 97 && s'::char <= 100 && s'::label = 1) || // accept character in class [a-d]+, stay in state [a-d]+
     (s'::char >= 100 && s'::char <= 102 && s'::label = 2) || // accept character in class [d-f]*, go to state [d-f]*
     (s'::char >= 108 && s'::char <= 110 && s'::label = 3))   // accept character in class [l-n], go to final state [l-n]
  )  &&
  (s::label = 2 => 
    ((s'::char >= 100 && s'::char <= 102 && s'::label = 2) || // accept character in class [d-f]*, stay in state [d-f]*
     (s'::char >= 108 && s'::char <= 110 && s'::label = 3))   // accept character in class [l-n], move to final state [l-n]
  )  &&
  (s'::label = 3 => s' in Final) // state is final, no more transitions possible

//minimize #Step
