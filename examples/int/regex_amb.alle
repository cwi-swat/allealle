// Encoding of regex ^[a-d]+[d-f]*[l-n]$
// Is this regex ambiguous? In other words, can we generate a string that can be parsed by this regex in multiple ways?
Trace (1)    = {<t1>,<t2>}
TraceOne (1) = {<t1>}
TraceTwo (1) = {<t2>}

Step (1 :: label:int, char:int, index:int)  <= {<s1,0,0,0>,<s2,?,?,?>..<s6,?,?,?>,
                                                <s7,0,0,0>,<s8,?,?,?>..<s12,?,?,?>}
step (2)                                    <= {<t1,s1>..<t1,s6>,
                                                <t2,s7>..<t2,s12>}
trans (2)                                   <= {<s1,s2>,<s2,s3>,<s3,s4>,<s4,s5>,<s5,s6>, 
                                                <s7,s8>,<s8,s9>,<s9,s10>,<s10,s11>,<s11,s12>}
Initial (1)  = {<s1>,<s7>}
Final (1)   <= {<s1>..<s12>}

// Generic constraints, equal for all regexes

step in Trace->Step
trans in Step->Step
Initial in Step

Step in Initial.*trans
forall s:Step | one step.s

(Step\Initial)::char > 0

Final in Step
forall t:Trace | one (Final & t.step)
no Final.trans

// Specific encoding for this regex as NFA

Step::label >= 0 && Step::label <= 3

Initial::label = 0
Final::label = 3

forall t:trans | let s:t.Step, s':Step.t | 
  (s::label = 0 => 
    (s'::char >= 97 && s'::char <= 100 && s'::label = 1) // accept character in class [a-d]+, move to state [a-d]+
  ) &&  
  (s::label = 1 => 
    ((s'::char >= 97 && s'::char <= 100 && s'::label = 1) || // accept character in class [a-d]+, stay in state [a-d]+
     (s'::char >= 100 && s'::char <= 102 && s'::label = 2) || // accept character in class [d-f]*, go to state [d-f]*
     (s'::char >= 108 && s'::char <= 110 && s'::label = 3))   // accept character in class [l-n], go to final state [l-n]
  )  &&
  (s::label = 2 => 
    ((s'::char >= 100 && s'::char <= 102 && s'::label = 2) || // accept character in class [d-f]*, stay in state [d-f]*
     (s'::char >= 108 && s'::char <= 110 && s'::label = 3))   // accept character in class [l-n], move to final state [l-n]
  )  &&
  (s'::label = 3 => s' in Final) // state is final, no more transitions possible
  && s'::index = s::index+1

#TraceOne.step = #TraceTwo.step

forall s:TraceOne.step, s':TraceTwo.step | s::index = s'::index => s::char = s'::char
exists s:TraceOne.step, s':TraceTwo.step | s::index = s'::index && s::label != s'::label 

minimize #Step
