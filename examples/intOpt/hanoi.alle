Disc (1 :: size:int)  = {<d3,3>,<d2,2>,<d1,1>}
Rod  (1)              = {<r1>,<r2>,<r3>}
GoalRod (1)           = {<r3>}
State (1)            >= {<s1>} <= {<s1>..<s8>}
InitialState (1)      = {<s1>}
ordering (2)         <= {<s1,s2>,<s2,s3>,<s3,s4>,<s4,s5>,<s5,s6>,<s6,s7>,<s7,s8>}
place (3)            >= {<s1,r1,d1>,<s1,r1,d2>,<s1,r1,d3>} <= {<s1,r1,d1>,<s1,r1,d2>,<s1,r1,d3>,<s2,r1,d1>..<s8,r3,d3>} 

place in State->Rod->Disc
ordering in State->State

State in InitialState.*ordering

forall s:State, d:Disc | one (s.place).d

exists s:State | Disc = GoalRod.(s.place)

forall s1:State, s2:State, d1:Disc  | let oldRodDisc1: (s1.place).d1, newRodDisc1: (s2.place).d1 | (s1->s2 in ordering && oldRodDisc1 != newRodDisc1) => 
    (forall d2:Disc\d1 | let oldRodDisc2: (s1.place).d2, newRodDisc2: (s2.place).d2 |
      oldRodDisc2 = newRodDisc2 &&
      ((oldRodDisc1 = oldRodDisc2 ||newRodDisc1 = newRodDisc2) => d2::size > d1::size) 
    )

minimize #State