Package (pId:id, size:int)              = {<a,1>,<b,1>,<c,0>,<d,1>,<e,0>,<f,0>,<g,1>,<h,0>,<y,0>,<z,0>}

InstallProfile (pId:id)                <= {<a>,<b>,<c>,<d>,<e>,<f>,<g>,<h>,<y>,<z>}

Installed (pId:id)                      = {<z>,<c>,<e>,<y>,<f>,<h>}
UninstallProfile (pId:id)              <= {<z>,<c>,<e>,<y>,<f>,<h>}
InstallPackage (pId:id)                 = {<a>}

depends (pId:id, dependsOn:id)          = {<a,b>,<a,c>,<a,z>,<b,d>,<c,d>,<c,e>,<c,f>,<c,g>,<y,z>,<f,h>}
dependChoice (pId:id, either:id, or:id) = {<c,d,e>,<c,e,d>,<c,f,g>,<c,g,f>}

conflicts (pId:id, with:id)             = {<d,e>,<d,f>}

// If the package to install is not yet installed then it should be in the installation profile
no (InstallPackage & Installed) => InstallPackage in InstallProfile

// If Package p' depends on package p and p' is reachable from a dependency from the package to install and p' is not yet installed 
forall p:Package[pId], p':Package[pId]-p | (p x p'[dependsOn/pId]) in depends && 
                                            p' in (InstallPackage |x| *<pId,dependsOn>depends) && 
                                            no p' & Installed && 
                                            not ((p |x| dependChoice |x| p'[either/pId] in Installed) =>
  (exists p'':Package\(p++p') | (p->p'->p'' in dependChoice) && (p' in InstallProfile || p'' in InstallProfile)) ||
  (no (p.dependChoice).p' && p' in InstallProfile)

forall p:InstallProfile, p':Package\p | p->p' in depends && no p' & Installed  => p' in InstallProfile 
no InstallProfile & Installed

forall p:Package, p':Package\p | p->p' in conflicts => not (p++p' in InstallProfile)

forall p:Package, p':Package\p | (p->p' in conflicts && p in InstallProfile && p' in Installed) => p' in UninstallProfile

no InstallProfile & UninstallProfile
forall p:UninstallProfile | some p.conflicts || some conflicts.p || (exists p':Package\p | p in p'.^depends)

//forall p:Installed, p':UninstallProfile\p | p in p'.^depends => p in UninstallProfile       
forall p:Installed, p':UninstallProfile\p | p in p'.^depends && (not (p in ((Installed\UninstallProfile)++InstallProfile).depends)) => p in UninstallProfile       

forall p:Installed | p in UninstallProfile && (some depends.p) && (depends.p in Installed) && (some ((depends.p).dependChoice).p) =>
    ( ((depends.p).dependChoice).p in InstallProfile ) 
    
minimize sum(InstallProfile::size)
minimize #UninstallProfile