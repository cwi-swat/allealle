PavingStone (pId:id, index:int) = {<p1,1>,<p2,2>,<p3,3>,<p4,4>,<p5,5>,<p6,6>}
Day (dId:id, nr:int)           >= {<d1,1>} <= {<d1,1>,<d2,2>,<d3,3>,<d4,4>,<d5,5>,<d6,6>,<d7,7>,<d8,8>,<d10,10>,<d11,11>,<d12,12>}
FirstDay (dId:id)               = {<d1>}
FinalDay (dId:id)              <= {<d1>..<d12>}
PivotDay (dId:id)              <= {<d1>..<d12>}
order (current:id,next:id)     <= {<d1,d2>,<d2,d3>,<d3,d4>,<d4,d5>,<d5,d6>,<d6,d7>,<d7,d8>,<d8,d9>,<d9,d10>,<d10,d11>,<d11,d12>}
under (dId:id,pId:id)          <= {<d1,p1>..<d12,p6>}
looked (dId:id,pId:id)         <= {<d1,p1>..<d12,p6>}

under in Day x PavingStone
looked in Day x PavingStone
order in Day x Day
FinalDay in Day
FirstDay in Day
PivotDay in Day

Day in FirstDay[current/dId] |x| *<current,next>order

no (FinalDay[current/dId] |x| order)
one FinalDay

some (FirstDay |x| looked |x| PavingStone) where index = 2

one PivotDay

some (PivotDay |x| Day) where nr = 4

forall d:Day | one (d |x| under) && one (d |x| looked)

forall o:order | let d1 = o[current][dId/current], d2 = o[next][dId/next] | 
  (d2 |x| under |x| PavingStone)::index = d1.under::index + 1) || (d2.under::index = d1.under::index - 1)

forall o:order | let d1:o.Day, d2:Day.o | 
  (d1::nr < PivotDay::nr => d2.looked::index = d1.looked::index + 1) &&
  (d1::nr = PivotDay::nr => d2.looked::index = d1.looked::index) &&
  (d1::nr > PivotDay::nr && d1.looked::index > 1 => d2.looked::index = d1.looked::index - 1) &&
  (d1::nr > PivotDay::nr && d1.looked::index = 1 => d2.looked::index = 1)
  
FinalDay.under = FinalDay.looked
forall d:Day\FinalDay | d.under != d.looked
//forall d:Day | d.under != d.looked

#Day = 8

maximize #under
