Time (1) <= {<t1>..<t6>}
Event (1) <= {<e1>..<e6>}
Room (1) <= {<r1>..<r6>}
Card (1) <= {<c1>..<c6>}
Key (1) <= {<k1>..<k6>}
Guest (1) <= {<g1>..<g6>}

first (1) = {<t1>}
last (1) <= {<t1>..<t6>}
next (2) <= {<t1,t2>..<t1,t6>,<t2,t3>..<t2,t6>,<t3,t4>..<t3,t6>,<t4,t5>,<t4,t6>,<t5,t6>}

pre (2) <= {<e1,t1>..<e6,t6>}
post (2) <= {<e1,t1>..<e6,t6>}

HotelEvent (1) <= {<e1>..<e6>}
RoomCardEvent (1) <= {<e1>..<e6>}
Checkin (1) <= {<e1>..<e6>}
Enter (1) <= {<e1>..<e6>}
NormalEnter (1) <= {<e1>..<e6>}
RecodeEnter (1) <= {<e1>..<e6>}
Checkout (1) <= {<e1>..<e6>} 

k1 (2) <= {<c1,k1>..<c6,k6>}
k2 (2) <= {<c1,k1>..<c6,k6>}

key (3) <= {<r1,k1,t1>..<r6,k6,t6>}
prev (3) <= {<r1,k1,t1>..<r6,k6,t6>}
occ (3) <= {<r1,g1,t1>..<r6,g6,t6>}

holds (3) <= {<g1,c1,t1>..<g6,c6,t6>}

guest (2) <= {<e1,g1>..<e6,g6>}
room (2) <= {<e1,r1>..<e6,r6>}
card (2) <= {<e1,c1>..<e6,c6>}

// Time Event invariants
one last
last in Time
Time = first.*next
no next.first
no last.next
forall t:Time\last | one t.next

pre in Event->Time
post in Event->Time
forall e:Event | one e.pre && one e.post

forall t:Time\last | one {e:Event | e.pre = t && e.post = t.next}

// card invariants
k1 in Card->Key
k2 in Card->Key
forall c:Card | one c.k1 && one c.k2

// room invariants
key in Room->Key->Time
prev in Room->Key->Time
occ in Room->Guest->Time
forall r:Room, t:Time | one r.key.t && lone r.prev.t

// guest invariants
holds in Guest->Card->Time

// init invariants
prev.first = key.first
key.first in Room->Key
forall k:Key | lone (key.first).k
no holds.first
no occ.first

// hotel event invariants
HotelEvent = Event
HotelEvent = RoomCardEvent+Checkout
no RoomCardEvent & Checkout
guest in HotelEvent->Guest
forall h:HotelEvent | one h.guest

// room card invariants
RoomCardEvent in HotelEvent
RoomCardEvent = Checkin+Enter
no Checkin & Enter
room in RoomCardEvent->Room
card in RoomCardEvent->Card
forall r:RoomCardEvent | one r.room && one r.card

// invariants for checkin
forall c:Checkin | no (c.room).occ.(c.pre) && 
                   (c.card).k1 = (c.room).prev.(c.pre) &&
                   holds.(c.post) = holds.(c.pre) + (c.guest->c.card) && 
                   prev.(c.post) = prev.(c.pre) ++ (c.room->(c.card).k2) &&
                   occ.(c.post) = occ.(c.pre) + (c.room->c.guest) &&
                   key.(c.pre) = key.(c.post)

// enter invariants
Enter in RoomCardEvent
Enter = NormalEnter + RecodeEnter
no NormalEnter & RecodeEnter
forall e:Enter | e.card in (e.guest).holds.(e.pre)
                
// normal enter invariants
NormalEnter in Enter
forall n:NormalEnter | (n.card).k2 = (n.room).key.(n.pre) &&
                       prev.(n.pre) = prev.(n.post) &&
                       holds.(n.pre) = holds.(n.post) &&
                       occ.(n.pre) = occ.(n.post) &&
                       key.(n.pre) = key.(n.post)
                       
// recode enter invariants
RecodeEnter in Enter

forall n:RecodeEnter | (n.card).k1 = (n.room).key.(n.pre) &&
                       key.(n.post) = key.(n.pre) ++ (n.room -> (n.card).k2) &&
                       prev.(n.pre) = prev.(n.post) &&
                       holds.(n.pre) = holds.(n.post) &&
                       occ.(n.pre) = occ.(n.post)
                       
// invariants for checkout
Checkout in HotelEvent
forall c:Checkout | some (occ.(c.pre)).(c.guest) &&
                    occ.(c.post) = occ.(c.pre) \ (Room->(c.guest)) &&
                    prev.(c.pre) = prev.(c.post) &&
                    holds.(c.pre) = holds.(c.post) &&
                    key.(c.pre) = key.(c.post)

// Always issue fresh key invariants
forall e1:Checkin, e2:Checkin\e1 | (e1.card).k2 != (e2.card).k2
forall e:Checkin | not ((e.card).k2 in (Room.key).first)        

// No intervening invariant
forall c:Checkin \ (pre.last) | 
  exists e:Enter | e.pre = c.post &&
                   e.room = c.room &&
                   e.guest = c.guest                              

// no bad entry
not (forall e:Enter | let occs: (e.room).(occ.(e.pre)) | some occs => e.guest in occs)                  
                   