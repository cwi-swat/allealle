Package (pId:id, size:int)              = {<a,1>,<b,1>,<c,0>,<d,1>,<e,0>,<f,0>,<g,1>,<y,0>,<z,0>}

InstallPackage (pId:id)                 = {<a>}

InstallProfile (pId:id)                <= {<a>,<b>,<c>,<d>,<f>,<g>,<y>}
UninstallProfile (pId:id)              <= {<z>,<e>}

Installed (pId:id)                      = {<z>,<e>}

depends (pId:id, dependsOn:id)          = {<a,b>,<a,c>,<a,z>,<b,d>,<c,d>,<c,e>,<c,f>,<c,g>,<y,z>}

interchangeable (pId:id, by:id)         = {<d,e>,<e,d>,<f,g>,<g,f>}
conflicts (pId:id, with:id)             = {<d,e>,<e,d>,<d,f>,<f,d>}

no InstallProfile ∩ UninstallProfile

let allDependendPackages = (InstallPackage ⨝ *<pId,dependsOn>depends)[dependsOn][pId/dependsOn] |
  ∀ p ∈ Package | (p[pId] ⊆ allDependendPackages ∧ no p[pId] ∩ Installed) ⇒ 
    (∃ i ∈ interchangeable | some (p ⨝ i) ∧ (p[pId] ⊆ InstallProfile ∨ i[by][pId/by] ⊆ InstallProfile)) ∨ 
      (no ((p[pId] ∩ interchangeable[pId]) ∪ (p[pId] ∩ interchangeable[by][pId/by])) ∧ 
      (¬ (∃ i ∈ interchangeable | (i[pId] ⊆ allDependendPackages) ∧ (i[pId] ⊆ InstallProfile ∨ i[pId] ⊆ Installed) ∧ (p[pId] ⊆ (i[by][pId/by] ⨝ (InstallPackage ⨝ *<pId,dependsOn>depends))[dependsOn][pId/dependsOn]))) 
        ⇒ p[pId] ⊆ InstallProfile)
                   
                    
∀ c ∈ conflicts | let p = c[pId], p' = c[with][pId/with] | (p ⊆ InstallProfile ∧ p' ⊆ Installed) ⇒ p' ⊆ UninstallProfile

//let allDependendPackages = (InstallPackage ⨝ *<pId,dependsOn>depends)[dependsOn][pId/dependsOn] |
//  ∀ p ∈ UninstallProfile | ∃ p' ∈ Package | p' ⊆ allDependedPackageg && 
//forall p:UninstallProfile | some p.conflicts || some conflicts.p || (exists p':Package\p | p in p'.^depends)
//
////forall p:Installed, p':UninstallProfile\p | p in p'.^depends => p in UninstallProfile       
//forall p:Installed, p':UninstallProfile\p | p in p'.^depends && (not (p in ((Installed\UninstallProfile)++InstallProfile).depends)) => p in UninstallProfile       
//
//forall p:Installed | p in UninstallProfile && (some depends.p) && (depends.p in Installed) && (some ((depends.p).dependChoice).p) =>
//    ( ((depends.p).dependChoice).p in InstallProfile ) 
//    

objectives: minimize (InstallProfile ⨝ Package)[totalSize/sum(size)], minimize UninstallProfile[cnt/count()]
