State (1)       >= {<s1>} <= {<s1>..<s8>}
InitialState (1) = {<s1>}
ordering (2)    <= {<s1,s2>,<s2,s3>,<s3,s4>,<s4,s5>,<s5,s6>,<s6,s7>,<s7,s8>}

Passenger (1)    = {<goat>,<wolf>,<cabbage>,<farmer>}
Farmer (1)       = {<farmer>}

eats (2)         = {<goat,cabbage>,<wolf,goat>}           

near (2)        >= {<s1,goat>,<s1,cabbage>,<s1,farmer>,<s1,wolf>} 
                <= {<s1,goat>..<s8,goat>,<s1,cabbage>..<s8,cabbage>,<s1,farmer>..<s8,farmer>,<s1,wolf>..<s8,wolf>} 

far (2)         <= {<s1,goat>..<s8,goat>,<s1,cabbage>..<s8,cabbage>,<s1,farmer>..<s8,farmer>,<s1,wolf>..<s8,wolf>}
             
ordering in State -> State
near in State -> Passenger
far in State -> Passenger

State in InitialState.*ordering

// a Passenger can only be on one shore in each state
forall s:State| no (s.near & s.far)

// All states should have all passengers on one side or another 
forall s:State | (s.near+s.far) = Passenger

// The goal is to get all Passengers to the other side compared to the start state
exists s:State | Passenger in s.far

// The farmer is always in the boat going from one shore to the other
//forall s1:State, s2: State | s1->s2 in ordering => (Farmer in s1.near => Farmer in s2.far) || (Farmer in s1.far => Farmer in s2.near)
forall o:ordering | let s1:o.State, s2:State.o | (Farmer in s1.near => Farmer in s2.far) || (Farmer in s1.far => Farmer in s2.near)

// During a transition the boat can only have at max one passenger
//forall s1:State, s2: State, p1:Passenger\Farmer, p2:Passenger\(Farmer+p1) | s1 -> s2 in ordering => (not ((p1+p2 in s1.near & s2.far) || p1+p2 in s1.far & s2.near))
forall o:ordering, p1:Passenger\Farmer, p2:Passenger\(Farmer+p1) | let s1:o.State, s2:State.o |(not ((p1+p2 in s1.near & s2.far) || p1+p2 in s1.far & s2.near))

// If a passengers goes from one side to the other it means that the Farmer also goes from the same side to the other
forall o:ordering, p:(Passenger\Farmer) | let s1:o.State, s2:State.o | ( ((p in s1.near & s2.far) => Farmer in s1.near & s2.far) &&
                                                                         ((p in s1.far & s2.near) => Farmer in s1.far & s2.near) )

// The Wolf can never be on the same shore then the Goat and the Cabbage can never be on the same shore then the Goat unless the Farmer is there as well
forall s:State, p1:Passenger, p2: Passenger | ((p1 -> p2 in eats) => ((p1 in s.near && p2 in s.far) || (p1 in s.far && p2 in s.near) || (p1+p2+Farmer in s.near) || (p1+p2+Farmer in s.far)))
